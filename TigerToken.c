// Usage (encryption): TigerToken -C/c plaintext.file ciphertext.file password
// Usage (decryption): TigerToken -P/p ciphertext.file plaintext.file password
// Compiled on MacOS, Linux and *BSD in X86_64 platform.
// Talk is SO EASY, show you my GOD.
// Simple is beautiful.

#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

unsigned short ausTigerTokens1[256] = {
    0x6919, 0x5804, 0x0442, 0x7A34, 0x2322, 0x0De2, 0x781B, 0x6239, 0x2D26, 0x187A, 0x3F51, 0x339E, 0x5832, 0x4Bd2, 0x41fA, 0x26b4,
    0x3B4B, 0x4C65, 0x1Db3, 0x536C, 0x0C70, 0x74c4, 0x5813, 0x52aE, 0x6EeC, 0x2115, 0x137C, 0x47fA, 0x4098, 0x1E11, 0x0D6B, 0x3B85,
    0x62fF, 0x43dD, 0x2Ed2, 0x7Ec2, 0x4C7E, 0x47bE, 0x369F, 0x3A4D, 0x5C54, 0x7379, 0x6B38, 0x44d1, 0x2772, 0x574D, 0x3E18, 0x7031,
    0x7C9F, 0x4Da9, 0x5E71, 0x55a9, 0x4B8E, 0x2030, 0x28a8, 0x3A09, 0x210F, 0x0BcD, 0x7B2C, 0x4636, 0x66bD, 0x7Bc4, 0x6EeB, 0x2711,
    0x0863, 0x1EaA, 0x590F, 0x3Df7, 0x450B, 0x7A6B, 0x7D09, 0x459F, 0x71e1, 0x722F, 0x040B, 0x6536, 0x0115, 0x4109, 0x1BcC, 0x08cE,
    0x7D8F, 0x3B1C, 0x1B85, 0x4396, 0x59a2, 0x5139, 0x42b1, 0x41b9, 0x4Ad1, 0x0118, 0x0792, 0x70cF, 0x3784, 0x1982, 0x165C, 0x7EfF,
    0x7F2E, 0x21bE, 0x0B2D, 0x0DaC, 0x5F98, 0x4179, 0x3670, 0x5069, 0x3B5B, 0x6302, 0x4714, 0x47b0, 0x367F, 0x6405, 0x59cE, 0x60d3,
    0x6Ba6, 0x2977, 0x21dE, 0x2C16, 0x48a6, 0x27e3, 0x0D49, 0x6Ac1, 0x735D, 0x7B0D, 0x0A60, 0x7691, 0x717E, 0x23c0, 0x1Cb2, 0x3691,
    0x4Eb9, 0x6F3F, 0x0D1D, 0x5Ae1, 0x25dC, 0x5D99, 0x16bB, 0x1E89, 0x7C95, 0x6BbA, 0x765E, 0x2873, 0x0BeF, 0x56d6, 0x1953, 0x4FeB,
    0x0Aa7, 0x1Ee0, 0x0E12, 0x280D, 0x21a1, 0x0B0C, 0x4DfD, 0x50d3, 0x760B, 0x5195, 0x71c4, 0x3188, 0x7F5C, 0x1545, 0x685E, 0x4176,
    0x4BbE, 0x6282, 0x145E, 0x0964, 0x037C, 0x6C28, 0x49dF, 0x110A, 0x2C8B, 0x6A59, 0x3493, 0x3433, 0x423E, 0x2Bd6, 0x5156, 0x50d8,
    0x40c2, 0x1117, 0x72f7, 0x2D5D, 0x4387, 0x74cF, 0x2Da0, 0x10b7, 0x3B9D, 0x0Ec3, 0x4EcF, 0x7486, 0x2999, 0x55e2, 0x414C, 0x650E,
    0x50fA, 0x7631, 0x20b7, 0x6A79, 0x27b2, 0x50f4, 0x13a9, 0x3181, 0x7B47, 0x7CcC, 0x5C03, 0x1E4C, 0x4222, 0x24e2, 0x0Fe5, 0x44c9,
    0x27a6, 0x6C7B, 0x520E, 0x6749, 0x6Af9, 0x5341, 0x02f7, 0x53d4, 0x2512, 0x7F6F, 0x300E, 0x340C, 0x0D78, 0x061E, 0x7712, 0x682B,
    0x5491, 0x0899, 0x03aA, 0x7E32, 0x7601, 0x0989, 0x4E16, 0x143C, 0x22eD, 0x7Ee9, 0x02fE, 0x0B3F, 0x3E19, 0x0A55, 0x2BfC, 0x5E8C,
    0x3A1C, 0x793F, 0x658D, 0x5692, 0x2096, 0x195C, 0x28c6, 0x7043, 0x69dB, 0x36eF, 0x655E, 0x2685, 0x539E, 0x5698, 0x6Ac0, 0x3C46};

unsigned short ausTigerTokens2[256] = {
    0x3D8D, 0x305D, 0x1E6A, 0x5007, 0x790C, 0x547B, 0x4743, 0x5C24, 0x77f0, 0x1263, 0x5A43, 0x7F6C, 0x1E23, 0x1A03, 0x4B02, 0x631D,
    0x4245, 0x68b7, 0x7C6D, 0x32d4, 0x7D55, 0x0E00, 0x29dC, 0x6709, 0x33d3, 0x0A08, 0x4139, 0x1Dc1, 0x534C, 0x3827, 0x7118, 0x03fA,
    0x2C4A, 0x0B6B, 0x6872, 0x3442, 0x278D, 0x7173, 0x1803, 0x1E59, 0x72aE, 0x2573, 0x1337, 0x38a0, 0x2939, 0x4Ce0, 0x0786, 0x41e3,
    0x2Cd6, 0x4B92, 0x492D, 0x0557, 0x446E, 0x18fF, 0x4Dc4, 0x11fB, 0x385D, 0x1297, 0x3896, 0x39aE, 0x3EeB, 0x7DeA, 0x7A18, 0x78b0,
    0x090A, 0x179B, 0x3339, 0x0124, 0x2BcA, 0x5FeF, 0x0A90, 0x0C78, 0x25bF, 0x095D, 0x615C, 0x1952, 0x70fD, 0x4AfD, 0x0Ef9, 0x22c9,
    0x76cE, 0x7080, 0x2689, 0x526E, 0x461A, 0x2261, 0x115B, 0x1Af0, 0x202D, 0x5C90, 0x1Ee8, 0x648E, 0x294D, 0x4318, 0x7D59, 0x35dF,
    0x2517, 0x3C82, 0x2135, 0x6460, 0x4947, 0x44b4, 0x42a4, 0x19b0, 0x0463, 0x0655, 0x5Ab7, 0x79aE, 0x0Ba6, 0x178E, 0x45b4, 0x06d1,
    0x796E, 0x7B14, 0x482D, 0x5947, 0x7B64, 0x29dD, 0x4E05, 0x309D, 0x4De9, 0x2FaE, 0x1Ea0, 0x3C5E, 0x223F, 0x541B, 0x7Ca0, 0x7Bd2,
    0x71aE, 0x4752, 0x6E60, 0x0022, 0x5AbC, 0x359E, 0x02dB, 0x6A18, 0x344E, 0x1452, 0x35e6, 0x1223, 0x1136, 0x6D9F, 0x4843, 0x3BaA,
    0x439E, 0x20d3, 0x7A8C, 0x060D, 0x0D7E, 0x0472, 0x4D99, 0x03aD, 0x3937, 0x01a1, 0x153D, 0x298D, 0x64f4, 0x7E05, 0x3252, 0x3742,
    0x0A6B, 0x1429, 0x1844, 0x3F66, 0x14e2, 0x4595, 0x5DbC, 0x0110, 0x7284, 0x3D9F, 0x289C, 0x2D1B, 0x7Cb0, 0x3262, 0x4951, 0x5415,
    0x08fB, 0x1365, 0x0259, 0x767F, 0x0E2D, 0x798E, 0x22fE, 0x47bD, 0x779B, 0x78e5, 0x1E1B, 0x5FaF, 0x0204, 0x152F, 0x1E02, 0x6F50,
    0x76e2, 0x31d7, 0x54eE, 0x2467, 0x200C, 0x6D5E, 0x4464, 0x47b1, 0x5562, 0x63e0, 0x1931, 0x46a2, 0x6C6F, 0x5894, 0x549B, 0x497B,
    0x465F, 0x3BfF, 0x78dA, 0x1Fc9, 0x7C90, 0x3Bf6, 0x02c1, 0x7A60, 0x0A40, 0x387C, 0x419C, 0x7452, 0x3EcF, 0x3659, 0x15c0, 0x4778,
    0x23b9, 0x4Bf4, 0x4219, 0x60c8, 0x1A15, 0x78a5, 0x20e9, 0x0092, 0x0B66, 0x7902, 0x490B, 0x4AbE, 0x4Eb8, 0x787E, 0x1C7F, 0x2F8A,
    0x3A69, 0x3E35, 0x2213, 0x651B, 0x3735, 0x02aB, 0x793E, 0x559D, 0x355D, 0x21c7, 0x0D02, 0x2382, 0x29c4, 0x566F, 0x7C19, 0x300D};

// swap the values of ausTigerTokens2
void swapValues(unsigned char *pucPassword, unsigned long long ulPasswordLength)
{
    for(unsigned long long i = 0; i < 64; ++i)
    {
        unsigned long long *pulSwap1 = (unsigned long long*)ausTigerTokens2, *pulSwap2 = (unsigned long long*)ausTigerTokens2, ulIndex, ulTemp;

        ulIndex = pucPassword[i % ulPasswordLength] % 64;

        ulTemp = pulSwap1[i];

        pulSwap1[i] = pulSwap2[ulIndex];

        pulSwap2[ulIndex] = ulTemp;
    }
}

// use the values of ausTigerTokens2 to change the password
void changePassword(unsigned char *pucPassword, unsigned long long ulPasswordLength)
{
    for(unsigned long long j = 0; j < ulPasswordLength; ++j)
    {
        pucPassword[j] = (unsigned char)ausTigerTokens2[pucPassword[j]];
    }
}

void Encrypt(unsigned char *pucPlaintextOrCiphertext, unsigned short *pusCiphertextOrPlaintext, unsigned long long ulFileSize, unsigned char *pucPassword, unsigned long long ulPasswordLength)
{
    for(unsigned long long i = 0; i < ulFileSize; i += 256)
    {
        swapValues(pucPassword, ulPasswordLength);

// use XOR to process the 256 bytes of plaintext at a time
        for(unsigned long long j = 0; j < 256 && i + j < ulFileSize; ++j)
        {
            pusCiphertextOrPlaintext[i + j] = ausTigerTokens1[pucPlaintextOrCiphertext[i + j]] ^ ausTigerTokens2[j];
        }

        changePassword(pucPassword, ulPasswordLength);
    }
}

void Decrypt(unsigned short *pusPlaintextOrCiphertext, unsigned char *pucCiphertextOrPlaintext, unsigned long long ulFileSize, unsigned char *pucPassword, unsigned long long ulPasswordLength)
{
    for(unsigned long long i = 0; i < ulFileSize; i += 256)
    {
        unsigned char aucTokens[65536] = {0};

// convert ausTigerTokens1 to aucTokens for data processing
        for(unsigned long long k = 0; k < 256; ++k)
        {
            aucTokens[ausTigerTokens1[k]] = k;
        }

        swapValues(pucPassword, ulPasswordLength);

// use XOR to process the 256 bytes of ciphertext at a time
        for(unsigned long long j = 0; j < 256 && i + j < ulFileSize; ++j)
        {
            pucCiphertextOrPlaintext[i + j] = aucTokens[pusPlaintextOrCiphertext[i + j] ^ ausTigerTokens2[j]];
        }

        changePassword(pucPassword, ulPasswordLength);
    }
}

int main(int argc, char *argv[])
{
    if(argv[1][0] == '-' && (argv[1][1] == 'c' || argv[1][1] == 'p' || argv[1][1] == 'C' || argv[1][1] == 'P'))
    {
// any password length
        unsigned long long ulPasswordLength = -1;

        while(argv[4][++ulPasswordLength]);

        struct stat statFileSize;

        stat(argv[2], &statFileSize);

// get the plaintext or ciphertext file size
        unsigned long long ulFileSize = statFileSize.st_size;

// allocate storage space
        unsigned char *pucPlaintextOrCiphertext = (unsigned char*)malloc(ulFileSize), *pucCiphertextOrPlaintext = NULL;

// open the plaintext or ciphertext file
        int iPlaintextOrCiphertext = open(argv[2], O_RDONLY, S_IRUSR | S_IWUSR);

// read data from the plaintext or ciphertext file
        read(iPlaintextOrCiphertext, pucPlaintextOrCiphertext, ulFileSize);

        close(iPlaintextOrCiphertext);

        if(argv[1][1] == 'c' || argv[1][1] == 'C')
        {
            ulFileSize *= 2;

            pucCiphertextOrPlaintext = (unsigned char*)malloc(ulFileSize);

            Encrypt(pucPlaintextOrCiphertext, (unsigned short*)pucCiphertextOrPlaintext, ulFileSize / 2, (unsigned char*)argv[4], ulPasswordLength);
        }
        else if(argv[1][1] == 'p' || argv[1][1] == 'P')
        {
            ulFileSize /= 2;

            pucCiphertextOrPlaintext = (unsigned char*)malloc(ulFileSize);

            Decrypt((unsigned short*)pucPlaintextOrCiphertext, pucCiphertextOrPlaintext, ulFileSize, (unsigned char*)argv[4], ulPasswordLength);
        }

// open the ciphertext or plaintext file
        iPlaintextOrCiphertext = open(argv[3], O_CREAT | O_WRONLY, S_IREAD | S_IWRITE);

// write data to the ciphertext or plaintext file
        write(iPlaintextOrCiphertext, pucCiphertextOrPlaintext, ulFileSize);

        close(iPlaintextOrCiphertext);

        free(pucCiphertextOrPlaintext);

        free(pucPlaintextOrCiphertext);
    }

    return 0;
}
