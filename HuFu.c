// Usage (encryption): HuFu -C/c plaintext.file ciphertext.file password
// Usage (decryption): HuFu -P/p ciphertext.file plaintext.file password
// Compiled on MacOS, Linux and *BSD in X86_64 platform.
// Talk is SO EASY, show you my GOD.
// Simple is beautiful.

#include <fcntl.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

unsigned short ausHuFu1[256] = {
    0x73fC, 0x35d2, 0x1E23, 0x42aA, 0x0C35, 0x4276, 0x2C95, 0x5B19, 0x1A61, 0x36d5, 0x267E, 0x566A, 0x6D3B, 0x0CeE, 0x10fC, 0x2832,
    0x5A74, 0x1324, 0x1EfB, 0x4BcE, 0x077A, 0x3133, 0x7035, 0x7173, 0x453B, 0x64c4, 0x06b7, 0x7152, 0x00e9, 0x6990, 0x66f5, 0x57aE,
    0x1E6F, 0x1Cb0, 0x0Dd8, 0x0482, 0x18e9, 0x2A14, 0x7302, 0x6426, 0x7F0A, 0x6Ac5, 0x49aC, 0x43f9, 0x7B48, 0x638B, 0x3545, 0x2CdC,
    0x7D8E, 0x4586, 0x70aC, 0x2C31, 0x13f7, 0x6141, 0x52cB, 0x54d7, 0x2B4C, 0x22fE, 0x279C, 0x1C56, 0x32d7, 0x6Dd8, 0x07e0, 0x1A72,
    0x5999, 0x1DbB, 0x6224, 0x1699, 0x3E2C, 0x6549, 0x1Bd7, 0x4CfD, 0x09e3, 0x66b2, 0x74fB, 0x2157, 0x5298, 0x2A0A, 0x2E51, 0x1858,
    0x419A, 0x04b4, 0x6963, 0x402A, 0x226B, 0x505F, 0x4Db5, 0x0576, 0x30cB, 0x7C48, 0x2E54, 0x65e5, 0x4D11, 0x210C, 0x27fF, 0x604D,
    0x0097, 0x38e2, 0x4606, 0x223B, 0x4A88, 0x5Aa4, 0x0631, 0x5680, 0x290C, 0x63c2, 0x4085, 0x4F4B, 0x37fD, 0x079D, 0x61e5, 0x00e5,
    0x6B18, 0x5Cc4, 0x5Df2, 0x1464, 0x7E10, 0x42aB, 0x43d7, 0x21aA, 0x0CeB, 0x32d8, 0x5Ed0, 0x613E, 0x5D0D, 0x1Ca4, 0x5425, 0x2735,
    0x7C18, 0x1198, 0x210D, 0x2DeC, 0x5E32, 0x3BbA, 0x2972, 0x6698, 0x56dD, 0x74f2, 0x7010, 0x3Ee0, 0x2Aa9, 0x239F, 0x31cF, 0x19a4,
    0x3F93, 0x7C00, 0x40bF, 0x4706, 0x1Ca7, 0x33bC, 0x1Ba3, 0x3688, 0x54aD, 0x7Ed4, 0x6Ae9, 0x0377, 0x2340, 0x7994, 0x3A0B, 0x37dB,
    0x50dE, 0x5D80, 0x10f7, 0x2Ab5, 0x1D3E, 0x3CbA, 0x00dC, 0x2912, 0x1Ab6, 0x35b4, 0x0Cd9, 0x0F1E, 0x31f8, 0x5Cf5, 0x0205, 0x256D,
    0x142A, 0x3Ae6, 0x06d3, 0x4BeC, 0x52e1, 0x3768, 0x33a8, 0x0E8D, 0x3F0A, 0x4Ff1, 0x7D33, 0x4B07, 0x180A, 0x1436, 0x0E91, 0x31fE,
    0x15b8, 0x1343, 0x0E77, 0x72d7, 0x02c3, 0x7Cc7, 0x4F0A, 0x7518, 0x1360, 0x4B44, 0x6F39, 0x66b8, 0x08e9, 0x5865, 0x0425, 0x4DdD,
    0x77dC, 0x339A, 0x707A, 0x537C, 0x3B15, 0x1De3, 0x4F5D, 0x36dC, 0x7969, 0x5A03, 0x6F2F, 0x0A80, 0x32c6, 0x5313, 0x028F, 0x46cD,
    0x3Fc4, 0x1544, 0x770D, 0x5013, 0x2A11, 0x4069, 0x0307, 0x111A, 0x72eC, 0x5060, 0x3Ce1, 0x01cC, 0x2B79, 0x63c9, 0x6F5E, 0x36c1,
    0x757C, 0x2C7E, 0x4FfF, 0x1557, 0x5362, 0x3B4F, 0x5FeD, 0x4C9F, 0x3F06, 0x1985, 0x37eB, 0x36bA, 0x75a3, 0x42f8, 0x607A, 0x5D08};

unsigned short ausHuFu2[256] = {
    0x3F21, 0x6760, 0x33c2, 0x6B49, 0x3990, 0x5E5C, 0x4921, 0x56bC, 0x2104, 0x4Bf8, 0x40fE, 0x2B1F, 0x4081, 0x01a0, 0x2879, 0x18f0,
    0x3337, 0x2259, 0x4997, 0x5B85, 0x2916, 0x1564, 0x29a9, 0x017B, 0x15fC, 0x27a7, 0x6Be7, 0x5882, 0x2599, 0x2B0D, 0x3D1E, 0x356C,
    0x301E, 0x6850, 0x30dF, 0x768B, 0x32e4, 0x3Da2, 0x21eD, 0x5Ec5, 0x68f4, 0x2652, 0x0F12, 0x00e1, 0x33e7, 0x62cA, 0x0B1E, 0x652B,
    0x1201, 0x3D4D, 0x0D8D, 0x1FbC, 0x3B6B, 0x0A53, 0x26a5, 0x1988, 0x3Db4, 0x0D89, 0x0766, 0x6408, 0x1Bd0, 0x13c6, 0x3659, 0x61a2,
    0x0Bc5, 0x5497, 0x75cF, 0x284E, 0x6001, 0x3D50, 0x2D97, 0x7B1A, 0x2De0, 0x6Ac0, 0x4751, 0x2Dc7, 0x2166, 0x5064, 0x3617, 0x2A28,
    0x675F, 0x4F84, 0x76fE, 0x37c3, 0x1B6E, 0x3807, 0x4Ae3, 0x3EdA, 0x5Bd9, 0x697A, 0x4672, 0x4D68, 0x6BdF, 0x10fE, 0x57b0, 0x4E21,
    0x003A, 0x1DeE, 0x330B, 0x3D4C, 0x469F, 0x4550, 0x7B03, 0x60cE, 0x73e7, 0x6BbC, 0x1BbF, 0x5836, 0x3D58, 0x49b3, 0x37cC, 0x2C4A,
    0x4A6F, 0x0408, 0x1362, 0x54d2, 0x0De2, 0x4E3E, 0x03d6, 0x77e5, 0x206F, 0x5DdE, 0x288A, 0x3Ab7, 0x2C2A, 0x57fD, 0x5494, 0x09b6,
    0x2902, 0x0Fb4, 0x3A61, 0x5Ac2, 0x2D2E, 0x02dD, 0x671D, 0x4684, 0x536B, 0x08dC, 0x5424, 0x3436, 0x6017, 0x1F00, 0x7999, 0x1C03,
    0x3481, 0x1C6A, 0x1119, 0x172E, 0x459F, 0x539D, 0x62d9, 0x4D2C, 0x0CaC, 0x4F18, 0x666E, 0x6F68, 0x7Fa5, 0x1073, 0x0D07, 0x62dC,
    0x45b2, 0x71b1, 0x54cD, 0x7FbF, 0x20fE, 0x5653, 0x5D8B, 0x307C, 0x4881, 0x591F, 0x3A21, 0x310D, 0x00b0, 0x3832, 0x1357, 0x5472,
    0x4049, 0x7D7F, 0x776B, 0x0931, 0x702D, 0x1E4D, 0x3B69, 0x6Fd5, 0x7972, 0x7591, 0x5500, 0x5715, 0x6F96, 0x6E9A, 0x7AfF, 0x03d8,
    0x1Ea0, 0x78fF, 0x5DaB, 0x3Ee5, 0x2729, 0x0790, 0x75fA, 0x1866, 0x2531, 0x0A3B, 0x2Cc5, 0x2B6A, 0x508E, 0x414D, 0x450A, 0x51dF,
    0x3EbC, 0x1Eb9, 0x4285, 0x4C30, 0x7454, 0x683A, 0x09c4, 0x0944, 0x210F, 0x20f4, 0x0508, 0x29e3, 0x0676, 0x3A41, 0x4D48, 0x76eB,
    0x4E04, 0x15c8, 0x623D, 0x3Cd0, 0x6F56, 0x7E44, 0x25fD, 0x1CdB, 0x7D2A, 0x71cA, 0x0347, 0x4BcB, 0x7Ad9, 0x1814, 0x200E, 0x293F,
    0x1A70, 0x1542, 0x778C, 0x2144, 0x1Eb6, 0x1EdB, 0x1F25, 0x6C57, 0x7C11, 0x742F, 0x2C02, 0x42d4, 0x0Fe1, 0x4026, 0x25e2, 0x795C};

// swap the values of ausHuFu1/ausHuFu2
void swapValues(unsigned long long *pulHuFu, unsigned char *pucPassword, unsigned long long ulPasswordLength)
{
    for(unsigned long long i = 0; i < 64; ++i)
    {
        unsigned long long *pulSwap1 = pulHuFu, *pulSwap2 = pulHuFu, ulIndex, ulTemp;

        ulIndex = pucPassword[i % ulPasswordLength] % 64;

        ulTemp = pulSwap1[i];

        pulSwap1[i] = pulSwap2[ulIndex];

        pulSwap2[ulIndex] = ulTemp;
    }
}

// use the values of ausHuFu1/ausHuFu2 to change the password
void changePassword(unsigned short *pusHuFu, unsigned char *pucPassword, unsigned long long ulPasswordLength)
{
    for(unsigned long long j = 0; j < ulPasswordLength; ++j)
    {
        pucPassword[j] = (unsigned char)pusHuFu[pucPassword[j]];
    }
}

void Encrypt(unsigned char *pucPlaintextOrCiphertext, unsigned short *pusCiphertextOrPlaintext, unsigned long long ulFileSize, unsigned char *pucPassword, unsigned long long ulPasswordLength)
{
    for(unsigned long long i = 0; i < ulFileSize; i += 256)
    {
        swapValues((unsigned long long*)ausHuFu1, pucPassword, ulPasswordLength);

        changePassword(ausHuFu1, pucPassword, ulPasswordLength);

        swapValues((unsigned long long*)ausHuFu2, pucPassword, ulPasswordLength);

// use XOR to process the 256 bytes of plaintext at a time
        for(unsigned long long j = 0; j < 256 && i + j < ulFileSize; ++j)
        {
            pusCiphertextOrPlaintext[i + j] = ausHuFu1[pucPlaintextOrCiphertext[i + j]] ^ ausHuFu2[j];
        }

        changePassword(ausHuFu2, pucPassword, ulPasswordLength);
    }
}

void Decrypt(unsigned short *pusPlaintextOrCiphertext, unsigned char *pucCiphertextOrPlaintext, unsigned long long ulFileSize, unsigned char *pucPassword, unsigned long long ulPasswordLength)
{
    for(unsigned long long i = 0; i < ulFileSize; i += 256)
    {
        swapValues((unsigned long long*)ausHuFu1, pucPassword, ulPasswordLength);

        changePassword(ausHuFu1, pucPassword, ulPasswordLength);

        swapValues((unsigned long long*)ausHuFu2, pucPassword, ulPasswordLength);

// use XOR to process the 256 bytes of ciphertext at a time
        for(unsigned long long j = 0; j < 256 && i + j < ulFileSize; ++j)
        {
            for(unsigned long long k = 0; k < 256; ++k)
            {
                if((pusPlaintextOrCiphertext[i + j] ^ ausHuFu2[j]) == ausHuFu1[k])
                {
                    pucCiphertextOrPlaintext[i + j] = k;

                    break;
                }
            }
        }

        changePassword(ausHuFu2, pucPassword, ulPasswordLength);
    }
}

int main(int argc, char *argv[])
{
    if(argv[1][0] == '-' && (argv[1][1] == 'c' || argv[1][1] == 'p' || argv[1][1] == 'C' || argv[1][1] == 'P'))
    {
// any password length
        unsigned long long ulPasswordLength = -1;

        while(argv[4][++ulPasswordLength]);

        struct stat statFileSize;

        stat(argv[2], &statFileSize);

// get the plaintext or ciphertext file size
        unsigned long long ulFileSize = statFileSize.st_size;

// allocate storage space
        unsigned char *pucPlaintextOrCiphertext = (unsigned char*)malloc(ulFileSize), *pucCiphertextOrPlaintext;

// open the plaintext or ciphertext file
        int iPlaintextOrCiphertext = open(argv[2], O_RDONLY, S_IRUSR | S_IWUSR);

// read data from the plaintext or ciphertext file
        read(iPlaintextOrCiphertext, pucPlaintextOrCiphertext, ulFileSize);

        close(iPlaintextOrCiphertext);

        if(argv[1][1] == 'c' || argv[1][1] == 'C')
        {
            ulFileSize *= 2;

            pucCiphertextOrPlaintext = (unsigned char*)malloc(ulFileSize);

            Encrypt(pucPlaintextOrCiphertext, (unsigned short*)pucCiphertextOrPlaintext, ulFileSize / 2, (unsigned char*)argv[4], ulPasswordLength);
        }
        else if(argv[1][1] == 'p' || argv[1][1] == 'P')
        {
            ulFileSize /= 2;

            pucCiphertextOrPlaintext = (unsigned char*)malloc(ulFileSize);

            Decrypt((unsigned short*)pucPlaintextOrCiphertext, pucCiphertextOrPlaintext, ulFileSize, (unsigned char*)argv[4], ulPasswordLength);
        }

// open the ciphertext or plaintext file
        iPlaintextOrCiphertext = open(argv[3], O_CREAT | O_WRONLY, S_IREAD | S_IWRITE);

// write data to the ciphertext or plaintext file
        write(iPlaintextOrCiphertext, pucCiphertextOrPlaintext, ulFileSize);

        close(iPlaintextOrCiphertext);

        free(pucCiphertextOrPlaintext);

        free(pucPlaintextOrCiphertext);
    }

    return 0;
}
